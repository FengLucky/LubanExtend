{{
	func gen_default_value
		if $0.type_name == 'bean'
			ret 'Schema.'+$0.def_bean.name+'.new_instance()'
		else if $0.type_name == 'set' || $0.type_name == 'list' || $0.type_name == 'map' || $0.type_name == 'array'
			ret '[]'
		else if $0.type_name == 'enum'
			ret $0.def_enum.name+'.'+$0.def_enum.items[0].name
		else if $0.type_name == 'int' || $0.type_name == 'float' || $0.type_name == 'double' || $0.type_name == 'byte' || $0.type_name == 'datetime' || $0.type_name == 'short' || $0.type_name == 'long'
			ret '0'
		else if $0.type_name == 'bool'
			ret 'false'
		else if $0.type_name == 'string'
			ret '""'
		end
	end	
}}

@tool
class_name Schema
extends RefCounted

static func _array_to_json(array:Array) -> Array[Variant]:
	var result := [];
	for item in array:
		if item is int or item is float or item is String or item is bool:
			result.push_back(item);
		else:
			result.push_back(item.to_json());
	return result;

static func _dict_to_json(dict:Dictionary) -> Array[Variant]:
	var result := [];
	for k in dict:
		var v = dict[k];
		if v is int or v is float or v is String or v is bool:
			result.push_back({k:v});
		else:
			result.push_back({k:v.to_json()});
	return result;
	
static func save_one_file(bean:Variant,path:String) -> void:
	var array := Schema._array_to_json([bean])
	var json := JSON.stringify(array,"\t")
	var access := FileAccess.open(path,FileAccess.WRITE)
	assert(access != null,"file open fail:"+path)
	assert(access.store_string(json),"file write fail:"+path)

{{~for enum in __enums~}}
{{~if enum.comment != '' ~}}
## {{enum.comment | html.escape}}
{{~end~}}
enum {{full_name enum}}
{
    {{~ for item in enum.items ~}}
    {{~if item.comment_or_alias != '' ~}}
    ## {{item.comment_or_alias | html.escape}}
    {{~end~}}
    {{item.name}} = {{item.value}},
    {{~end~}}
}

static func get_{{full_name enum}}_alias(value:{{full_name enum}}) -> String:
	match value:
	{{~ for item in enum.items ~}}
		{{item.value}}:
			{{~if item.alias != ''~}}
			return "{{item.alias | html.escape}}"
			{{~else~}}
			return "{{item.name}}"
			{{~end~}}
	{{~end~}}
		_:
			return "Unknown"

{{~end~}}
{{~for bean in __beans
    name = (full_name bean)
~}}
{{~if bean.comment != '' ~}}
## {{bean.comment | html.escape}}
{{~end~}}
class {{name}}{{if bean.parent_def_type}} extends {{full_name bean.parent_def_type}}{{end}}:
{{~ for field in bean.export_fields ~}}
    {{~if field.comment != '' ~}}
    ## {{field.comment | html.escape}}
    {{~end~}}
	var {{format_field_name __code_style field.name}}: {{declaring_type_name field.ctype}}
{{~end~}}

	static func new_instance() -> Schema.{{name}}:
		{{~if bean.export_fields.empty?~}}
		return Schema.{{name}}.new(null);
		{{~else~}}
		return Schema.{{name}}.new({
		{{~ for field in bean.export_fields ~}}
			"{{format_field_name __code_style field.name}}": {{gen_default_value field.ctype}},
		{{~end~}}
		})
		{{~end~}}

{{~if bean.is_abstract_type~}}
	static func fromJson(_json_):
		var type = _json_['$type']
		match type:
        {{~ for child in bean.hierarchy_not_abstract_children~}}
			"{{impl_data_type child bean}}": return {{full_name child}}.new(_json_)
        {{~end~}}
			_: assert(false)

{{~end~}}
	func _init(_json_) -> void:
{{~if bean.parent_def_type~}}
		super(_json_)
{{~end~}}
        {{~ for field in bean.export_fields ~}}
		{{deserialize_field ('self.' + (format_field_name __code_style field.name)) '_json_' field.name field.ctype}}
        {{~end~}}
        {{~if bean.export_fields.empty?~}}
		pass
        {{~end~}}
        
	func duplicate() -> Schema.{{name}}:
		var dict := to_json();
		var json := JSON.stringify(dict);
		return Schema.{{name}}.new(json);
	
	func to_json() -> Dictionary[String, Variant]:
		{{~if bean.export_fields.empty?~}}
		{{~if bean.parent_def_type~}}
		return {"$type" : "{{name}}"}
		{{~else~}}
		return {}
		{{~end~}}
		{{~else~}}
		return {
		{{~if bean.parent_def_type~}}
		"$type" : "{{name}}",
		{{~end~}}
		{{~ for field in bean.export_fields ~}}
		{{~if field.ctype.type_name == 'set' || field.ctype.type_name == 'list'~}}
		"{{field.name}}" : Schema._array_to_json(self.{{format_field_name __code_style field.name}}),
		{{~else if field.ctype.type_name == 'map'~}}
		"{{field.name}}" : Schema._dict_to_json(self.{{format_field_name __code_style field.name}}),
		{{~else if field.ctype.is_bean~}}
		"{{field.name}}" : self.{{format_field_name __code_style field.name}}.to_json(),
		{{~else~}}
		"{{field.name}}" : self.{{format_field_name __code_style field.name}},
		{{~end~}}
		{{~end~}}
		}
		{{~end~}}
		
{{~end~}}

{{~for table in __tables
    value_type = table.value_ttype
    value_type_name = (declaring_type_name value_type)
~}}

{{~if table.tags['editor'] != nil ~}}
{{~if table.comment != '' ~}}
## {{table.comment | html.escape}}
{{~end~}}
class {{full_name table}} extends RefCounted:
	{{~ 
		_params = ''
		_condition = ''
		_condition_with_item = ''
		_values = ''
		_values_with_item = ''
		_first = true
		for INDEX in table.index_list
			if !_first
				_params += ', '
				_values += ', '
				_values_with_item += ', '
				_condition += ' and '
				_condition_with_item += ' and '
			end
			_first = false
			_params += (format_field_name __code_style INDEX.index_field.name) + ':' + (declaring_type_name INDEX.index_field.ctype)
			_condition += 'item.' + INDEX.index_field.name + ' == ' + (format_field_name __code_style INDEX.index_field.name)
			_condition_with_item += 'bean.' + INDEX.index_field.name + ' == item.' + (format_field_name __code_style INDEX.index_field.name)
			_values += (format_field_name __code_style INDEX.index_field.name)
			_values_with_item += 'item.' + INDEX.index_field.name
		end
	~}}

    {{~if table.is_map_table || table.is_list_table && table.index_list.size == 1~}}
	var _data_list: Array[Schema.{{value_type_name}}] = [];
	var _data_map: Dictionary[{{declaring_type_name table.index_field.ctype}},Schema.{{value_type_name}}] = {};
	
	static func load_from_dir(__dir:String) -> Schema.{{full_name table}}:
		var files := DirAccess.get_files_at(__dir);
		var table = Schema.{{full_name table}}.new("");
		for file in files:
			table._load_one_file(__dir + file);
		return table;
	
	func _init(__path:String) -> void:
		_load_one_file(__path);
		
	func _parse_from_json(json:String,replace:bool = false) ->void:
		var items = JSON.parse_string(json)
		for item in items:
			var v := Schema.{{value_type_name}}.new(item)
			if replace:
				remove_item(v);
			self._data_list.append(v)
			self._data_map[v.{{format_field_name __code_style table.index_field.name}}] = v
		
	func reload_file(__path:String) -> void:
		_load_one_file(__path,true);
			
	func new_config({{format_field_name __code_style table.index_field.name}} : {{declaring_type_name table.index_field.ctype}}) -> Schema.{{value_type_name}}:
		assert(!self._data_map.has({{format_field_name __code_style table.index_field.name}}),"{{format_field_name __code_style table.index_field.name}}=" + str({{format_field_name __code_style table.index_field.name}}) + " already exists");
		var config = Schema.{{value_type_name}}.new_instance()
		config.{{format_field_name __code_style table.index_field.name}} = {{format_field_name __code_style table.index_field.name}};
		return config;
		
	func duplicate_item(item:Schema.{{value_type_name}},{{format_field_name __code_style table.index_field.name}} : {{declaring_type_name table.index_field.ctype}}) -> Schema.{{value_type_name}}:
		assert(!self._data_map.has({{format_field_name __code_style table.index_field.name}}),"{{format_field_name __code_style table.index_field.name}}=" + str({{format_field_name __code_style table.index_field.name}}) + " already exists");
		var config := item.duplicate();
		config.{{format_field_name __code_style table.index_field.name}} = {{format_field_name __code_style table.index_field.name}};
		return config;

	func add_item(item:Schema.{{value_type_name}}):
		assert(!self._data_map.has(item.{{format_field_name __code_style table.index_field.name}}),"{{format_field_name __code_style table.index_field.name}}=" + str(item.{{format_field_name __code_style table.index_field.name}}) + " already exists")	
		self._data_map.set(item.{{format_field_name __code_style table.index_field.name}}, item)
		self._data_list.append(item)
	
	func remove_item(item:Schema.{{value_type_name}}):
		self._data_map.erase(item.{{format_field_name __code_style table.index_field.name}})
		var index := self._data_list.find_custom(func (bean:Schema.{{value_type_name}}) -> bool:
			return bean.{{format_field_name __code_style table.index_field.name}} == item.{{format_field_name __code_style table.index_field.name}}
		)
		if index >= 0:
			self._data_list.remove_at(index)

	func get_data_list() -> Array[Schema.{{value_type_name}}]:
		return self._data_list

	func get_data_map() -> Dictionary:
		return self._data_map

	func get_item(key : {{declaring_type_name table.index_field.ctype}}) -> Schema.{{value_type_name}}:
		return self._data_map.get(key)

    {{~else if table.multi_key ~}}
	var _data_list: Array[Schema.{{value_type_name}}] = [];
    {{~ for INDEX in table.index_list ~}}
	var _{{INDEX.index_field.name}}_data_map: Dictionary[{{declaring_type_name INDEX.index_field.ctype}},Schema.{{value_type_name}}] = {};
    {{~ end ~}} 
    
	static func load_from_dir(__dir:String) -> Schema.{{full_name table}}:
		var files := DirAccess.get_files_at(__dir);
		var table = Schema.{{full_name table}}.new("");
		for file in files:
			table._load_one_file(__dir + file);
		return table;
	
	func _init(__path:String) -> void:
		if __path.is_empty():
			return
		_load_one_file(__path);
	
	func _parse_from_json(json:String,replace:bool = false) ->void:
		var items = JSON.parse_string(json)
		for item in items:
			var v := Schema.{{value_type_name}}.new(item)
			if replace:
				remove_item(v);
			self._data_list.append(v)
		{{~ for INDEX in table.index_list ~}}
			self._{{INDEX.index_field.name}}_data_map[v.{{INDEX.index_field.name}}] = v
		{{~ end ~}}
		
	func reload_file(__path:String) -> void:
		_load_one_file(__path,true);
  
	func new_config({{~_params~}}) -> Schema.{{value_type_name}}:
		{{~ for INDEX in table.index_list ~}}
		assert(!self._{{INDEX.index_field.name}}_data_map.has({{format_field_name __code_style INDEX.index_field.name}}),"{{format_field_name __code_style INDEX.index_field.name}}=" + str({{format_field_name __code_style INDEX.index_field.name}}) + " already exists");
		{{~ end ~}}
		var config = Schema.{{value_type_name}}.new_instance()
		{{~ for INDEX in table.index_list ~}}
		config.{{format_field_name __code_style INDEX.index_field.name}} = {{format_field_name __code_style INDEX.index_field.name}};
		{{~ end ~}}
		return config;
		
	func duplicate_item(item:Schema.{{value_type_name}},{{~_params~}}) -> Schema.{{value_type_name}}:
		{{~ for INDEX in table.index_list ~}}
		assert(!self._{{INDEX.index_field.name}}_data_map.has({{format_field_name __code_style INDEX.index_field.name}}),"{{format_field_name __code_style INDEX.index_field.name}}=" + str({{format_field_name __code_style INDEX.index_field.name}}) + " already exists");
		{{~ end ~}}
		var config := item.duplicate()
		{{~ for INDEX in table.index_list ~}}
		config.{{format_field_name __code_style INDEX.index_field.name}} = {{format_field_name __code_style INDEX.index_field.name}};
		{{~ end ~}}
		return config;
		
	func add_item(item:Schema.{{value_type_name}}):
		{{~ for INDEX in table.index_list ~}}
		assert(!self._{{INDEX.index_field.name}}_data_map.has(item.{{INDEX.index_field.name}}),"{{format_field_name __code_style INDEX.index_field.name}}=" + str(item.{{INDEX.index_field.name}}) + " already exists")
		{{~ end ~}}
		{{~ for INDEX in table.index_list ~}}
		self._{{INDEX.index_field.name}}_data_map.set(item.{{format_field_name __code_style INDEX.index_field.name}}, item)
		{{~ end ~}}
		self._data_list.append(item)
	
	func remove_item(item:Schema.{{value_type_name}}):
		{{~ for INDEX in table.index_list ~}}
		self._{{INDEX.index_field.name}}_data_map.erase(item.{{INDEX.index_field.name}})
		{{~ end ~}}
		var index := self._data_list.find_custom(func (bean:Schema.{{value_type_name}}) -> bool:
			return {{_condition_with_item}}
		)
		if index >= 0:
			self._data_list.remove_at(index)

	func get_data_list() -> Array[Schema.{{value_type_name}}]:
		return self._data_list

    {{~ for INDEX in table.index_list ~}}
	func get_{{INDEX.index_field.name}}_data_map() -> Dictionary:
		return self._{{INDEX.index_field.name}}_data_map
		
    {{~ end ~}}
{{~ for INDEX in table.index_list ~}}
	func get_item_by_{{INDEX.index_field.name}}({{INDEX.index_field.name}}:{{declaring_type_name INDEX.index_field.ctype}}) -> Schema.{{value_type_name}}:
		return self._{{INDEX.index_field.name}}_data_map.get({{INDEX.index_field.name}})

{{~ end ~}}
    {{~else if table.is_list_table ~}}
	var _data_list: Array[Schema.{{value_type_name}}]
	
	{{~if table.index_list.size > 1~}}
	static func load_from_dir(__dir:String) -> Schema.{{full_name table}}:
		var files := DirAccess.get_files_at(__dir);
		var table = Schema.{{full_name table}}.new("");
		for file in files:
			table._load_one_file(__dir + file);
		return table;
	{{~end~}}
	
	func _init(__path:String) -> void:
		if __path.is_empty():
			return
		_load_one_file(__path);
		
	func _parse_from_json(json:String,{{~if table.index_list.size > 1~}}replace{{~else~}}_replace{{~end~}}:bool = false) ->void:
		var items = JSON.parse_string(json);
		for item in items:
			var v := Schema.{{value_type_name}}.new(item)
			{{~if table.index_list.size > 1~}}
			if replace:
				remove_item(v);
			{{~end~}}
			self._data_list.append(v)
	{{~if table.index_list.size > 1~}}
	func reload_file(__path:String) -> void:
		_load_one_file(__path,true);
	{{~end~}}
			
	func new_config({{~_params~}}) -> Schema.{{value_type_name}}:
		{{~if table.index_list.size > 1~}}
		assert(self.get_item_by_union({{~_values~}}) == null,"union index allready exists");
		{{~end~}}
		var config = Schema.{{value_type_name}}.new_instance()
		{{~ for INDEX in table.index_list ~}}
		config.{{format_field_name __code_style INDEX.index_field.name}} = {{format_field_name __code_style INDEX.index_field.name}};
		{{~ end ~}}
		return config;
		
	func duplicate_item(item:Schema.{{value_type_name}},{{~_params~}}) -> Schema.{{value_type_name}}:
		{{~if table.index_list.size > 1~}}
		assert(self.get_item_by_union({{~_values~}}) == null,"union index allready exists");
		{{~end~}}
		var config := item.duplicate();
		{{~ for INDEX in table.index_list ~}}
		config.{{format_field_name __code_style INDEX.index_field.name}} = {{format_field_name __code_style INDEX.index_field.name}};
		{{~ end ~}}
		return config;
		
	func add_item(item:Schema.{{value_type_name}}):
		{{~if table.index_list.size > 1~}}
		assert(self.get_item_by_union({{~_values_with_item~}}) == null,"union index allready exists")
		{{~end~}}
		self._data_list.append(item)
		
	{{~if table.index_list.size > 1~}}
	func remove_item(item:Schema.{{value_type_name}}):
		var index := self._data_list.find_custom(func (bean:Schema.{{value_type_name}}) -> bool:
			return {{_condition_with_item}}
		)
		if index >= 0:
			self._data_list.remove_at(index)
	{{~else~}}
	func remove_item(index:int):
		if index >= 0:
			self._data_list.remove_at(index)
	{{~end~}}

	func get_data_list() -> Array[Schema.{{value_type_name}}]:
		return self._data_list
    
	func get_item(index : int) -> Schema.{{value_type_name}}:
		return self._data_list[index]
		
	{{~if table.index_list.size > 1~}}
	func get_item_by_union({{_params}}) -> Schema.{{value_type_name}}:
		for item in self._data_list:
			if {{_condition}}:
				return item
		return null;
		
	{{~end~}}	
	
    {{~else~}}
	var _data:Schema.{{value_type_name}}
			
	func _init(__path:String) -> void:
		if __path.is_empty():
			self._data = Schema.{{value_type_name}}.new_instance();
			return
		_load_one_file(__path);
		
	func _parse_from_json(json:String,_replace:bool = false) ->void:
		var items = JSON.parse_string(json);
		self._data = Schema.{{value_type_name}}.new(items[0]);
		
	func get_data() -> Schema.{{value_type_name}}:
		return self._data

    {{~ for field in value_type.def_bean.hierarchy_export_fields
     name = format_field_name __code_style field.name
     ~}}
{{~if field.comment != '' ~}}
	## {{escape_comment field.comment}}
{{~end~}}
	var {{name}}: {{declaring_type_name field.ctype}}:
		get: return self._data.{{name}}
		set(value): self._data.{{name}} = value

    {{~end~}}
    {{~end~}}
	func duplicate() -> Schema.{{full_name table}}:
		var table = Schema.{{full_name table}}.new("");
		table._parse_from_json(to_json());
		return table;
    
	func save_to_json(__path:String) -> void:
		var access := FileAccess.open(__path,FileAccess.WRITE)
		assert(access != null,"file open fail:"+__path)
		assert(access.store_string(to_json()),"file write fail:"+__path)
		
	func to_json() -> String:
		{{~if table.is_singleton_table ~}}
		var array := Schema._array_to_json([self._data])
		{{~else~}}
		var array := Schema._array_to_json(self._data_list)
		{{~end~}}
		return JSON.stringify(array,"\t")
		
	func _load_one_file(__path:String,replace:bool = false) -> void:
		if __path.is_empty():
			return
		assert(FileAccess.file_exists(__path),"file does not exist:"+__path);
		_parse_from_json(FileAccess.get_file_as_string(__path),replace);
{{~end~}}
{{~end~}}